[{"ref":"https://kaustubhpatange.github.io/blog/post/agp-enableuncompressednativelibs/","title":"The undocumented AGP's gradle property.","section":"post","date":"2021.10.03","body":"One of the scariest experience where I was about to break my production app due to my unfamiliarity with AGP\u0026rsquo;s android.bundle.enableUncompressedNativeLibs gradle property.\nThis was the time when I was about to release a new app on Google Play called Gear VPN, completely ignorant about this issue that only occurs when you create an app bundle to publish on Google Play.\nThe problem So my app has many native libraries (.so) which are loaded at runtime to execute some commands at runtime. This was working completely fine on debug \u0026amp; release builds because the optimization only happens for app bundle. Keep in mind that if you test the app on pre M devices the app will work fine \u0026amp; will not break due to this optimization.\nWhat is this optimization? Below are the screenshot of the app\u0026rsquo;s /data/app folder when installed in different modes.\n   Package (.apk) - Release Bundle (.aab) - Release          As you can notice, for the \u0026ldquo;Bundle\u0026rdquo; no libs (specific to device architecture) are extracted in lib folder which means any call to System.loadLibrary() or directly executing binary (that contains path like getApplicationInfo().nativeLibDir) will fail internally without producing any crash.\nBut what actually happens? On \u0026amp; after M, the platform supports reading native libraries directly from the APK without having to extract them. This is why we don\u0026rsquo;t see a lib folder when the app is installed from the app bundle. So any argument passed to execute a command through this library will not work since the directory getApplicationInfo().nativeLibDir doesn\u0026rsquo;t exists.\nThis issue actually broke my app\u0026rsquo;s core feature. Thanks to some of the internal testers who verified this issue before me publishing to the production.\nSolution There are mainly two solutions,\n If you are the maintainer of the library then remove getApplicationInfo().nativeLibDir call from System.loadLibrary() for post L devices \u0026amp; instead directly specify the library name as the platform then supports reading them directly from the APK. You can also opt out of this optimization by setting android.bundle.enableUncompressedNativeLibs flag to false in gradle.properties file.  For my app, since it was a third party library my only available option was to go with the gradle property solution.\nWhy was this optimization added? Disabling the optimization leads to bigger APKs on users devices since the native libraries are extracted out of the APK (and thus also longer installation times).\n pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } "},{"ref":"https://kaustubhpatange.github.io/blog/post/coroutine-parallelism/","title":"Parallelism in suspend functions","section":"post","date":"2021.09.29","body":"We know how to execute parallel suspend functions in a CoroutineScope, but how to do it within a suspend function that has a return type.\nThe Problem For what we know it is not hard to run multiple suspend functions parallelly in a CoroutineScope using async {} block. async\u0026rsquo;s return type is Deferred\u0026lt;T\u0026gt; which then can be awaited so it is possible to chain multiple Deferred\u0026lt;T\u0026gt; jobs using awaitAll which solves the problem of parallelism.\nsuspend fun taskList1() = \u0026#34;Some text data\u0026#34; suspend fun taskList2() = \u0026#34;Another random data\u0026#34; suspend fun parallelNoReturnType() { CoroutineScope(Dispatchers.IO).launch { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) // process data \u0026amp; return unit  } } Certainly, this is not a problem but what if the return type of the function is other than Unit meaning there is need for a non Unit return type. Certainly returning the total variable from above will not work as it is in the @launch scope, also returning the CoroutineScope will not work since it\u0026rsquo;s return type is Job not List\u0026lt;String\u0026gt; which we are expecting.\n// Eg: 1 - Returning total variable (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... return total // Error  } } // Eg: 2 - Returning CoroutineScope (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { // Valid return type but it\u0026#39;s not List\u0026lt;String\u0026gt;; Error  return CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... total // hoping this would be the result just like `run` function  } } Solution The easy fix is to use coroutineScope { } suspend function which has a signature public suspend fun \u0026lt;R\u0026gt; coroutineScope(block: suspend CoroutineScope.() -\u0026gt; R): R.\nFor us the R is List\u0026lt;String\u0026gt;, using it in the above code requires minimal edit.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = coroutineScope scope@{ val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@scope total } The coroutineScope uses the default coroutineContext associated with the suspend function i.e the parent\u0026rsquo;s coroutine context which was used to invoke this suspend function.\nIf you want to dispatch the jobs on some other CoroutineDispatcher you can use .async {} on CoroutineScope.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = CoroutineScope(Dispatchers.Default).async { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@async total }.await() // important otherwise the return type will be Deferred\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;   pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } "}]