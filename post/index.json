[{"ref":"https://kaustubhpatange.github.io/blog/post/singlecheck-vs-doublecheck/","title":"Dagger's implementation of JSR 330","section":"post","date":"2021.10.19","body":"We will see some of the Dagger 2 generated code more specifically on how it uses SingleCheck\u0026lt;T\u0026gt; \u0026amp; DoubleCheck\u0026lt;T\u0026gt; implementations of javax.inject.Provider\u0026lt;T\u0026gt; internally.\nWhenever you create a @Component or @Subcomponent, dagger creates an implementation extending your type with some fields (from your modules \u0026amp; submodules), constructor \u0026amp; an initialize method.\n@Singleton // this is just a scope, we can use a custom one if we want. @Component(modules = [AppModule::class]) interface AppComponent { ... @Component.Factory interface Factory { // BindInstance ties parameter within the component heirarchy so it  // can be accessed/used in modules, subcomponents, etc.  fun create(@BindInstance application Application) : AppComponent } fun inject(app: CustomApplication) // `CustomApplication` is my application class. } // Dagger generated code public final class DaggerAppComponent implements AppComponent { private final AppModule appModule; private final Application application; ... // `AppModule` contents are omitted for brevity.  public DaggerAppComponent(AppModule appModuleParam, Application applicationParam) { this.appModule = appModuleParam; this.application = applicationParam; initialize(appModuleParam, applicationParam); } private void initialize(final AppModule appModuleParam, final Application applicationParam) { ... } @Override public void inject(CustomApplication app) { // used to inject in my Application class.  ... } } As you can see the Component.Factory or Component.Builder method parameters will become the arguments for the constructor \u0026amp; are stored in the private fields of the class. If @BindInstance is not be applied to the create method, we won\u0026rsquo;t be seeing private final Application application; as dagger assumes it is only needed to construct the component and not to been used in any modules or submodules. If you try to use it within Module or component heirarchy then dagger will throw a compile time error as the field does not exist.\nAppModule Let\u0026rsquo;s take a real example from an app which has AppModule as follows.\nclass NetworkUtils @Inject constructor (...) { fun getOkHttpBuilder() : OkHttpClient.Builder { ... } fun getRetrofitBuilder() : Retrofit.Builder { ... } } @Module class AppModule { @Provides fun provideMyApi(networkUtils: NetworkUtils) : IpApi { return networkUtils.getRetrofitBuilder() ... .create(...) } } Whenever you add @javax.inject.Inject annotation, dagger will create a factory class eg: For NetworkUtils, NetworkUtils_Factory.java will be created implementing dagger.internal.Factory\u0026lt;T\u0026gt; which itself is a Provider\u0026lt;T\u0026gt;. It will also create factories for all the @Provide methods in your module eg: AppModule_ProvideMyApiFactory.\nA Provider\u0026lt;T\u0026gt; contains single method get() : T which generate or provide an instance of the T. The optimization happens for this get() : T method, whether to provide a new instance or reuse existing instance (which was cached after initialization for the first time).\nFor this we can use scope annotations which dagger provides to create a custom scope or use an existing one (@Reusable, @Singleton in our case, we will see this later).\nFor now, the dependencies injected in my application class would generate the follow dagger code.\nfun CustomApplication : Application() { val appComponent: AppComponent = DaggerAppComponent.create(this) @Inject lateinit var myApi : MyApi @Inject lateinit var networkUtils : NetworkUtils fun onCreate() { appComponent.inject(this) // using the inject method defined in `DaggerAppComponent`  ... } } public final class DaggerAppComponent implements AppComponent { ... // from above  private Provider\u0026lt;MyApi\u0026gt; provideMyApiProvider; // Factory for `provideMyApi` method  private void initialize(...) { // `create` or return as existing factory class.  // Remember `create` method will return a factory \u0026amp; `get` will return an instance depending on how  // many times it has been wrapped with a Provider\u0026lt;T\u0026gt;.  this.provideMyApiProvider = AppModule_ProvideMyApiFactory.create(..., NetworkUtils_Factory.create()); } @Override public void inject(CustomApplication app) { injectApp(app); } private App injectApp(CustomApplication instance) { // internally `provideMyApi` call will delegate the call to `AppModule.provideIpApi(...)`  instance.myApi = AppModule_ProvideMyApiFactory.provideMyApi(appModule, new NetworkUtils(...)); instance.networkUtils = new NetworkUtils(...); } } The inject method actually sets the value for the fields in the CustomApplication. But we observe that we are always providing a new instance of NetworkUtils whenever requested. Let\u0026rsquo;s see how can we customize this behavior.\n Note: Similar results will be produced if we try to @Provide NetworkUtils via a module.\n Scoped annotations   @Reusable   From the docs,\n @Reusable is useful when you want to limit the number of provisions of a type, but there is no specific lifetime over which there must be only one instance.\n Hmm, so it says there is no guarantee that the cached instance could be a singleton \u0026amp; there is a chance that it could be reinitialized (in an edge case, maybe?).\nLet\u0026rsquo;s see how the generated code looks.\n@Reusable class NetworkUtils @Inject constructor (...) { ... } // Dagger generated code public final class DaggerAppComponent implements AppComponent { ... private Provider\u0026lt;NetworkUtils\u0026gt; provideNetworkUtilsProvider; ... private void initialize(...) { this.networkUtilsProvider = SingleCheck.provider(NetworkUtils_Factory.create(provideApplicationContextProvider)); } } We see it wraps our factory provider using SingleCheck\u0026lt;T\u0026gt;. But what does it do?\nFrom the SingleCheck\u0026lt;T\u0026gt; docs,\n A Provider implementation that memoizes the result of another Provider using simple lazy initialization, not the double-checked lock pattern.\n So it caches the result using \u0026ldquo;simple\u0026rdquo; lazy initialization \u0026amp; is able to provide the cached instance when requested. But it could break under certain circumstances, I\u0026rsquo;ll answer the \u0026ldquo;when\u0026rdquo; question later.\n  @Singleton   There are no restrictions on only using @Singleton annotation, you can create a custom one but don\u0026rsquo;t forget to annotate your @Component or @Subcomponent with it. In my case, I annotated AppComponent with @Singleton which means any dependency annotated with @Singleton will bind to AppComponent \u0026amp; will live as long as AppComponent lives (i.e tied to the Application).\nLets see how the generated code looks like when we annotate NetworkUtils with it.\n@Singleton class NetworkUtils @Inject constructor (...) { ... } // Dagger generated code public final class DaggerAppComponent implements AppComponent { ... private Provider\u0026lt;NetworkUtils\u0026gt; provideNetworkUtilsProvider; ... private void initialize(...) { this.networkUtilsProvider = DoubleCheck.provider(NetworkUtils_Factory.create(provideApplicationContextProvider)); } } Instead of SingleCheck\u0026lt;T\u0026gt; we see the use of DoubleCheck\u0026lt;T\u0026gt; provider.\nFrom the DoubleCheck\u0026lt;T\u0026gt; docs,\n A Lazy and Provider implementation that memoizes the value returned from a delegate using the double-check idiom described in Item 71 of Effective Java 2.\n From this statement I know that I need to read the Item 71 of Effective Java 2 to understand lazy initialization in more depth.\n Note: If you inject your dependency using dagger.Lazy\u0026lt;T\u0026gt; provider then you will see DoubleCheck.lazy(...) in the generated code where you have to manually call .get() to retrieve the dependency in the calling code. The working is same but the dependency is only initialized when .get() is called for the first time.\n SingleCheck\u0026lt;T\u0026gt; vs DoubleCheck\u0026lt;T\u0026gt; From the docs, we know both of these idioms are used for lazy initializations \u0026amp; after reading Item 71 of Effective Java 2 I\u0026rsquo;m sure DoubleCheck\u0026lt;T\u0026gt; is thread safe. Lets explore them,\n  Simple lazy initialization (Single check idiom)   Here I\u0026rsquo;ve created a simple copy-paste-run sample that initializes the field lazily (no locking).\nclass Box // Single check idiom used by `SingleCheck\u0026lt;T\u0026gt;` class Container { companion object { @Volatile // writes to this field are immediately made visible to other threads  private var box: Box? = null fun getBox() : Box { var field = box if (field == null) { box = Box() field = box } return field!! } } } fun thread1() { Thread { val field = Container.getField() println(\u0026#34;Value from thread1: $field\u0026#34;) }.start() } fun thread2() { Thread { val field = Container.getField() println(\u0026#34;Value from thread2: $field\u0026#34;) }.start() } fun main() { thread1() thread2() /* Output * ------ * Value from thread 2: Box@6ae36b9b * Value from thread 1: Box@667c6a02 */ } The order of println is not guaranteed but we see both the accessor of Box in these two threads are different. This is because the SingleCheck\u0026lt;T\u0026gt; idiom is not thread safe \u0026amp; could cause repeated initialization when we try to access the field from different threads at the same time.\n  Double check idiom (locking pattern)   The way this idiom is implemented is first we check the field if it is uninitialized without locking, then we lock the object \u0026amp; again check the field if uninitialized. If it appears to be uninitialized the second time we initialize the field \u0026amp; return it in both the cases.\nWe modify the Container class to follow this idiom \u0026amp; run the main function again.\n// Double check idiom (thread safe) used by `DoubleCheck\u0026lt;T\u0026gt;` class Container { companion object { @Volatile private var box: Box? = null fun getField() : Box { var field = box if (field == null) { synchronized(this) { field = box if (field == null) { box = Box() field = box } } } return field!! } } } fun main() { thread1() thread2() /* Output * ------ * Value from thread 2: Box@6b925f95 * Value from thread 1: Box@6b925f95 */ } We\u0026rsquo;ve achieved thread safety as both the threads have the same instance of Box.\nConclusion  The optimization happens only on Provider\u0026lt;T\u0026gt;.get(T) which could be recursive, hence some checks like DoubleCheck\u0026lt;T\u0026gt;.reentrantCheck are made to avoid transitivity. If we use @Reusable then dagger caches the factory provider using SingleCheck\u0026lt;T\u0026gt; idiom which is not thread safe \u0026amp; can cause repeated initialization if the field is accessed from different threads at the same time. Hence, the docs says \u0026ldquo;limit the number of provisions of a type\u0026rdquo; not a single instance. Using @Singleton or injecting via dagger.Lazy\u0026lt;T\u0026gt; caches the factory provider using DoubleCheck\u0026lt;T\u0026gt; idiom which is thread safe.   pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } .article { text-align: start; } "},{"ref":"https://kaustubhpatange.github.io/blog/post/agp-enableuncompressednativelibs/","title":"The undocumented AGP's gradle property.","section":"post","date":"2021.10.03","body":"One of the scariest experience where I was about to break my production app due to my unfamiliarity with AGP\u0026rsquo;s android.bundle.enableUncompressedNativeLibs gradle property.\nThis was the time when I was about to release a new app on Google Play called Gear VPN, completely ignorant about this issue that only occurs when you create an app bundle to publish on Google Play.\nThe problem So my app has many native libraries (.so) which are loaded at runtime to execute some commands at runtime. This was working completely fine on debug \u0026amp; release builds because the optimization only happens for app bundle. Keep in mind that if you test the app on pre M devices the app will work fine \u0026amp; will not break due to this optimization.\nWhat is this optimization? Below are the screenshot of the app\u0026rsquo;s /data/app folder when installed in different modes.\n   Package (.apk) - Release Bundle (.aab) - Release          As you can notice, for the \u0026ldquo;Bundle\u0026rdquo; no libs (specific to device architecture) are extracted in lib folder which means any call to System.loadLibrary() or directly executing binary (that contains path like getApplicationInfo().nativeLibDir) will fail internally without producing any crash.\nBut what actually happens? On \u0026amp; after M, the platform supports reading native libraries directly from the APK without having to extract them. This is why we don\u0026rsquo;t see a lib folder when the app is installed from the app bundle. So any argument passed to execute a command through this library will not work since the directory getApplicationInfo().nativeLibDir doesn\u0026rsquo;t exists.\nThis issue actually broke my app\u0026rsquo;s core feature. Thanks to some of the internal testers who verified this issue before me publishing to the production.\nSolution There are mainly two solutions,\n If you are the maintainer of the library then remove getApplicationInfo().nativeLibDir call from System.loadLibrary() for post L devices \u0026amp; instead directly specify the library name as the platform then supports reading them directly from the APK. You can also opt out of this optimization by setting android.bundle.enableUncompressedNativeLibs flag to false in gradle.properties file.  For my app, since it was a third party library my only available option was to go with the gradle property solution.\nWhy was this optimization added? Disabling the optimization leads to bigger APKs on users devices since the native libraries are extracted out of the APK (and thus also longer installation times).\n pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } .article { text-align: start; } "},{"ref":"https://kaustubhpatange.github.io/blog/post/coroutine-parallelism/","title":"Parallelism in suspend functions","section":"post","date":"2021.09.29","body":"We know how to execute parallel suspend functions in a CoroutineScope, but how to do it within a suspend function that has a return type.\nThe Problem For what we know it is not hard to run multiple suspend functions parallelly in a CoroutineScope using async {} block. async\u0026rsquo;s return type is Deferred\u0026lt;T\u0026gt; which then can be awaited so it is possible to chain multiple Deferred\u0026lt;T\u0026gt; jobs using awaitAll which solves the problem of parallelism.\nsuspend fun taskList1() = \u0026#34;Some text data\u0026#34; suspend fun taskList2() = \u0026#34;Another random data\u0026#34; suspend fun parallelNoReturnType() { CoroutineScope(Dispatchers.IO).launch { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) // process data \u0026amp; return unit  } } Certainly, this is not a problem but what if the return type of the function is other than Unit meaning there is need for a non Unit return type. Certainly returning the total variable from above will not work as it is in the @launch scope, also returning the CoroutineScope will not work since it\u0026rsquo;s return type is Job not List\u0026lt;String\u0026gt; which we are expecting.\n// Eg: 1 - Returning total variable (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... return total // Error  } } // Eg: 2 - Returning CoroutineScope (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { // Valid return type but it\u0026#39;s not List\u0026lt;String\u0026gt;; Error  return CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... total // hoping this would be the result just like `run` function  } } Solution The easy fix is to use coroutineScope { } suspend function which has a signature public suspend fun \u0026lt;R\u0026gt; coroutineScope(block: suspend CoroutineScope.() -\u0026gt; R): R.\nFor us the R is List\u0026lt;String\u0026gt;, using it in the above code requires minimal edit.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = coroutineScope scope@{ val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@scope total } The coroutineScope uses the default coroutineContext associated with the suspend function i.e the parent\u0026rsquo;s coroutine context which was used to invoke this suspend function.\nIf you want to dispatch the jobs on some other CoroutineDispatcher you can use .async {} on CoroutineScope.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = CoroutineScope(Dispatchers.Default).async { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@async total }.await() // important otherwise the return type will be Deferred\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;   pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } .article { text-align: start; } "}]