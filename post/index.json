[{"ref":"https://kaustubhpatange.github.io/blog/post/coroutine-parallelism/","title":"Parallelism in suspend functions","section":"post","date":"2021.09.29","body":"We know how to execute parallel suspend functions in a CoroutineScope, but how to do it within a suspend function that has a return type.\nThe Problem For what we know it is not hard to run multiple suspend functions parallelly in a CoroutineScope using async {} block. async\u0026rsquo;s return type is Deferred\u0026lt;T\u0026gt; which then can be awaited so it is possible to chain multiple Deferred\u0026lt;T\u0026gt; jobs using awaitAll which solves the problem of parallelism.\nsuspend fun taskList1() = \u0026#34;Some text data\u0026#34; suspend fun taskList2() = \u0026#34;Another random data\u0026#34; suspend fun parallelNoReturnType() { CoroutineScope(Dispatchers.IO).launch { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) // process data \u0026amp; return unit  } } Certainly, this is not a problem but what if the return type of the function is other than Unit meaning there is need for a non Unit return type. Certainly returning the total variable from above will not work as it is in the @launch scope, also returning the CoroutineScope will not work since it\u0026rsquo;s return type is Job not List\u0026lt;String\u0026gt; which we are expecting.\n// Eg: 1 - Returning total variable (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... return total // Error  } } // Eg: 2 - Returning CoroutineScope (will not compile) suspend fun parallelReturnType() : List\u0026lt;String\u0026gt; { // Valid return type but it\u0026#39;s not List\u0026lt;String\u0026gt;; Error  return CoroutineScope(...).launch { ... val total: List\u0026lt;String\u0026gt; = ... total // hoping this would be the result just like `run` function  } } Solution The easy fix is to use coroutineScope { } suspend function which has a signature public suspend fun \u0026lt;R\u0026gt; coroutineScope(block: suspend CoroutineScope.() -\u0026gt; R): R.\nFor us the R is List\u0026lt;String\u0026gt;, using it in the above code requires minimal edit.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = coroutineScope scope@{ val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@scope total } The coroutineScope uses the default coroutineContext associated with the suspend function i.e the parent\u0026rsquo;s coroutine context which was used to invoke this suspend function.\nIf you want to dispatch the jobs on some other CoroutineDispatcher you can use .async {} on CoroutineScope.\nsuspend fun parallelReturnType() : List\u0026lt;String\u0026gt; = CoroutineScope(Dispatchers.Default).async { val task1 = async { taskList1() } val task2 = async { taskList2() } val total: List\u0026lt;String\u0026gt; = awaitAll(task1, task2) return@async total }.await() // important otherwise the return type will be Deferred\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;   pre code, pre, code { white-space: pre !important; overflow-x: auto !important; word-break: keep-all !important; word-wrap: initial !important; } "}]